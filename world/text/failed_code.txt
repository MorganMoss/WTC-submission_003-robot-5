
    # def make_map(self):
    #     if len(self.obstacles.obstacles) > 0:
    #         random_obstacle = self.obstacles.obstacles.pop()
    #         self.obstacles.obstacles.add(random_obstacle)
    #         x_offset = self.cell_size/2#random_obstacle.pos[0]%self.cell_size
    #         y_offset = self.cell_size/2#random_obstacle.pos[1]%self.cell_size

    #         self.map_of_maze = {
    #             x : {
    #                 y : 1
    #                 if self.obstacles.is_position_blocked(
    #                     x*self.cell_size+x_offset,y*self.cell_size+y_offset) else 0
    #                 for y in range(
    #                     -self.bounds_y[1]/self.cell_size, self.bounds_y[1]/self.cell_size+1)
    #             } 
    #             for x in range(
    #                 -self.bounds_x[1]/self.cell_size, self.bounds_x[1]/self.cell_size+1)}

    #         for row in self.map_of_maze.values():
    #             for col in row.values():
    #                 print(col,end='')
    #             print()

    # def explore_zeros(self, x, y):

    #     val = self.map_of_maze[x][y] 
    #     if x > -self.bounds_x[1]//self.cell_size and not self.map_of_maze[x-1][y]:
    #         self.map_of_maze[x-1][y] = val + 1
    #         self.explore_zeros(x-1,y)

    #     if x < self.bounds_x[1]//self.cell_size and not self.map_of_maze[x+1][y]:
    #         self.map_of_maze[x+1][y] = val + 1
    #         self.explore_zeros(x+1,y)

    #     if y > -self.bounds_y[1]//self.cell_size and not self.map_of_maze[x][y-1]:
    #         self.map_of_maze[x][y-1] = val + 1
    #         self.explore_zeros(x,y-1) 

    #     if y < self.bounds_y[1]//self.cell_size and not self.map_of_maze[x][y+1]:
    #         self.map_of_maze[x][y+1] = val + 1
    #         self.explore_zeros(x,y+1)


    # def backtrace(self, x, y):

    #     val = self.map_of_maze[x][y]
    #     if val >= 3:
    #         val -= 1
    #         if x > -self.bounds_x[1]//self.cell_size and self.map_of_maze[x-1][y] == val:
    #             self.path.append((x-1,y))
    #             self.backtrace((x-1)*self.cell_size,y*self.cell_size)

    #         elif x < self.bounds_x[1]//self.cell_size and self.map_of_maze[x+1][y] == val:
    #             self.path.append((x+1,y))
    #             self.backtrace((x+1)*self.cell_size,y*self.cell_size)

    #         elif y > -self.bounds_y[1]//self.cell_size and self.map_of_maze[x][y-1] == val:
    #             self.path.append((x*self.cell_size,(y-1)*self.cell_size))
    #             self.backtrace(x,y-1)

    #         elif y < self.bounds_y[1]//self.cell_size and self.map_of_maze[x][y+1] == val:
    #             self.path.append((x*self.cell_size,(y+1)*self.cell_size))
    #             self.backtrace(x,y+1)


    # def mazerun(self, robot:ToyRobot, goal_pos:tuple):
    #     self.make_map()

    #     self.map_of_maze[
    #         self.robot_pos[robot.name][0]][
    #         self.robot_pos[robot.name][1]
    #     ] = 2

    #     self.map_size_x = len(self.map_of_maze)
    #     self.map_size_y = len(self.map_of_maze[0])


    #     self.index = 0 if goal_pos[0] else 1
        
    #     self.explore_zeros(*self.robot_pos[robot.name])

        
    #     self.path = []

    #     if not self.index:
    #         for y in range(self.bounds_y[0], self.bounds_y[1]+1):
    #             if self.map_of_maze[goal_pos[0]][y] > 1:
    #                 self.backtrace(goal_pos[0],y)
    #                 break
    #     else:
    #         y = round(self.map_size_y//2*(goal_pos[1]/abs(goal_pos[1])))
    #         for x in range(-self.map_size_x//2+1, self.map_size_x//2+1):
    #             if self.map_of_maze[x][y] > 1:
    #                 self.backtrace(x,self.map_size_y//2*(goal_pos[1]/abs(goal_pos[1])))   
    #                 break
                    
    #     self.path.reverse()
        
        