

    def find_manhattan_distance(self, x1:int,y1:int,x2:int,y2:int) -> int:
        """
        This function takes in two co-ordinates and calculates it's
        Manhattan Distance (MD). In summary this takes the x and y deltas
        and adds them together

        Args:
            x1, y1 (int): The first point
            x2, y2 (int): The second point

        Returns:
            int: The Manhattan Distance between the points
        """
        return abs(x2-x1) + abs(y2-y1)


    def is_hugging_right(self, robot:ToyRobot) -> bool:
        """
        Checks if this robot has a wall to it's right

        Args:
            robot (ToyRobot): The robot being checked

        Returns:
            bool: True if a wall is adjacent to the right side of the robot
        """

        self.robot_direction[robot.name] = (
            self.robot_direction[robot.name] 
            + 90
        )%360
        destination = self.get_destination(robot, self.cell_size)
        hugging_right = (
            self.obstacles.is_path_blocked(
                *self.robot_pos[robot.name], 
                *destination)
            or not self.destination_in_bounds(destination)
        )
        self.robot_direction[robot.name] = (
            self.robot_direction[robot.name] 
            - 90
        )%360   
        return hugging_right


    def right_hand_algorithm_iteration(self, robot:ToyRobot):
        """
        It does a single iteration of the right hand maze solving algorithm
        on a specific robot, this entials hugging a wall in essence.

        Args:
            robot (ToyRobot): The robot controlled in this process
        """
        if not self.is_hugging_right(robot):
            self.rotate_robot(robot, 90)
            self.move_robot(robot, self.cell_size)
            return
            
        if not self.move_robot(robot, self.cell_size):
            self.rotate_robot(robot, 180)


    def find_productive_path(
        self, robot:ToyRobot, goal_pos:tuple):
        """AI is creating summary for find_productive_path

        Args:
            robot (ToyRobot): The robot being used to solve the maze
            goal_pos (tuple): The edge to go to

        Returns:
            tuple: The direction that gets closer to the edge 
            and how far the new distance is. 
            Returns false if no path has a smaller MD.
        """
        directions = [0,0,0,0]  # up, right, down, left
        
        for i in range(4):
            destination = self.get_destination(robot, self.cell_size)
            if (
                not self.obstacles.is_path_blocked(
                    *self.robot_pos[robot.name], 
                    *destination)
                and self.destination_in_bounds(destination)
            ):
                directions[i]  = self.find_manhattan_distance(
                    *destination,*goal_pos
                )
            self.robot_direction[robot.name] = (
                self.robot_direction[robot.name] 
                + 90
            )%360
        
        shortest = reduce(
            lambda a,b : a if b>a else b,
            filter(lambda x : x > 0, directions)
        ) 

        smallest_manhattan_distance = self.find_manhattan_distance(
                    *self.robot_pos[robot.name],*goal_pos
                )
        if shortest < smallest_manhattan_distance and shortest > 0:
            return shortest, directions.index(shortest)
        else:
            return False


    def mazerun_slow(self, robot:ToyRobot, goal_pos:tuple):
        """
        Solves the maze by trying all paths with the turtle.

        Args:
            robot (ToyRobot): The robot to be moved around
            goal_pos (tuple): The edge to land on
        """
        robot.messages_enabled = False
        index = 0 if goal_pos[0] else 1
        if index:
            for x in range(
                self.bounds_x[0]+1, self.bounds_x[1]-2, self.cell_size):
                if not (x, goal_pos[1]) in self.obstacles:
                    goal_pos = (x, goal_pos[1])
                    break

        else:
            for y in range(
                self.bounds_y[0]+1, self.bounds_y[1]-2, self.cell_size):
                if not (goal_pos[0], y) in self.obstacles:
                    goal_pos = (goal_pos[0], y)
                    break
        
        lenience = range(
            goal_pos[index]-self.cell_size+2, goal_pos[index]+self.cell_size-1)

        smallest_manhattan_distance = self.find_manhattan_distance(
            *self.robot_pos[robot.name],*goal_pos
        )
        while not self.robot_pos[robot.name][index] in lenience:
            productive_path = self.find_productive_path(robot, goal_pos)
            if productive_path:
                self.rotate_robot(robot, 90*productive_path[1])
                self.move_robot(robot, self.cell_size)
                self.rotate_robot(robot, -90*productive_path[1])
            else:
                smallest_manhattan_distance = self.find_manhattan_distance(
                    *self.robot_pos[robot.name],*goal_pos
                )

                rotation = - self.robot_direction[robot.name]
                if index:
                    if goal_pos[1] < 0:
                        rotation -= 180
                else:
                    if goal_pos[0] < 0:
                        rotation -= 90
                    else:
                        rotation += 90
                rotation -= 90
                self.rotate_robot(robot, rotation)
                self.move_robot(robot, self.cell_size)
                if self.robot_pos[robot.name][index] in lenience:
                    break
                while not (
                    self.find_productive_path(robot, goal_pos) 
                    and self.find_manhattan_distance(
                        *self.robot_pos[robot.name]
                        ,*goal_pos
                    ) == smallest_manhattan_distance
                ):
                    if self.robot_pos[robot.name][index] in lenience:
                        break
                    self.right_hand_algorithm_iteration(robot)
        robot.messages_enabled = True





FOR TURTLE:

    
    def mazerun_slow(self, robot: ToyRobot, goal_pos: tuple):
        """
        Solves the maze by trying all paths with the turtle.

        Args:
            robot (ToyRobot): The robot to be moved around
            goal_pos (tuple): The edge to land on
        """
        self.robot_turtles[robot].speed(0)
        robot.robot_say_message(
            "Do you wish to watch the process? (y/n) : ", end='')
        if not input().lower() == 'y':
            self.screen.tracer(0)
        super().mazerun_slow(robot, goal_pos)
        self.screen.tracer(1)
        self.robot_turtles[robot].speed(1)
